use crate::*;
use alloc::collections::BTreeMap;
use frame_support::{traits::Get, traits::OnRuntimeUpgrade, weights::Weight};
use log::{debug, info};
use sp_std::marker::PhantomData;

#[cfg(feature = "try-runtime")]
use codec::Decode;
#[cfg(feature = "try-runtime")]
use sp_std::vec::Vec;

pub struct MigrateTwinsV15<T: Config>(PhantomData<T>);

impl<T: Config> OnRuntimeUpgrade for MigrateTwinsV15<T> {
    #[cfg(feature = "try-runtime")]
    fn pre_upgrade() -> Result<Vec<u8>, &'static str> {
        info!("current pallet version: {:?}", PalletVersion::<T>::get());
        assert!(PalletVersion::<T>::get() >= types::StorageVersion::V14Struct);

        let twins_count: u64 = Twins::<T>::iter().count() as u64;
        log::info!(
            "ðŸ”Ž MigrateTwinsV15 pre migration: Number of existing twins {:?}",
            twins_count
        );

        info!("ðŸ‘¥  TFGrid pallet to v14 passes PRE migrate checks âœ…",);
        Ok(twins_count.encode())
    }

    fn on_runtime_upgrade() -> Weight {
        if PalletVersion::<T>::get() == types::StorageVersion::V14Struct {
            migrate_twins::<T>()
        } else {
            info!(" >>> Unused TFGrid pallet V15 migration");
            Weight::zero()
        }
    }

    #[cfg(feature = "try-runtime")]
    fn post_upgrade(pre_twins_count: Vec<u8>) -> Result<(), &'static str> {
        info!("current pallet version: {:?}", PalletVersion::<T>::get());
        assert!(PalletVersion::<T>::get() >= types::StorageVersion::V15Struct);

        // Check number of twins against pre-check result
        let pre_twins_count: u64 = Decode::decode(&mut pre_twins_count.as_slice())
            .expect("the state parameter should be something that was generated by pre_upgrade");
        assert_eq!(
            Twins::<T>::iter().count() as u64,
            pre_twins_count,
            "Number of twins migrated does not match"
        );

        info!(
            "ðŸ‘¥  TFGrid pallet migration to {:?} passes POST migrate checks âœ…",
            Pallet::<T>::pallet_version()
        );

        Ok(())
    }
}

pub fn migrate_twins<T: Config>() -> frame_support::weights::Weight {
    info!(" >>> Migrating twin storage...");

    let mut read_writes = 0;

    Twins::<T>::translate::<super::types::v14::Twin<Vec<u8>, AccountIdOf<T>>, _>(|k, twin| {
        debug!("migrated twin: {:?}", k);

        let new_twin = types::Twin {
            id: twin.id,
            account_id: twin.account_id,
            relay: None,
            entities: twin.entities,
            pk: None,
        };

        read_writes += 1;
        Some(new_twin)
    });

    // Update pallet storage version
    PalletVersion::<T>::set(types::StorageVersion::V15Struct);
    info!(" <<< Twin migration success, storage version upgraded");

    // Return the weight consumed by the migration.
    T::DbWeight::get().reads_writes(read_writes, read_writes + 1)
}

pub fn migrate_to_version_8<T: Config>() -> frame_support::weights::Weight {
    debug!(
        " >>> Starting contract pallet migration, pallet version: {:?}",
        PalletVersion::<T>::get()
    );

    let mut reads = 0;
    let mut writes = 0;

    let mut twin_contract_locked_balances: BTreeMap<u32, BalanceOf<T>> = BTreeMap::new();
    // Fetch all locked balances based on the contract locks in storage and accumulate them by twin id
    for (ctr_id, l) in ContractLock::<T>::iter() {
        let ctr = Contracts::<T>::get(ctr_id);
        reads += 1;
        match ctr {
            Some(contract) => {
                reads += 1;
                if !pallet_tfgrid::Twins::<T>::contains_key(contract.twin_id) {
                    debug!(
                        "twins: {} does not exist, removing contract and lock",
                        contract.twin_id
                    );
                    Contracts::<T>::remove(ctr_id);
                    ContractLock::<T>::remove(ctr_id);
                    writes += 2;
                } else {
                    *twin_contract_locked_balances
                        .entry(contract.twin_id)
                        .or_default() += l.amount_locked;
                }
            }
            None => {
                debug!(
                    "no contract found for contract lock {}, cleaning up lock..",
                    ctr_id
                );
                writes += 1;
                ContractLock::<T>::remove(ctr_id);
            }
        }
    }

    for (twin_id, t) in pallet_tfgrid::Twins::<T>::iter() {
        reads += 1;

        // If the twin needs to have some locked balance on his account because of running contracts
        // Check how much we can actually lock based on his current total balance
        // this will make sure the locked balance will not exceed the total balance on the twin's account
        let should_lock = twin_contract_locked_balances.get(&twin_id).map(|b| {
            debug!(
                "contract locked balance on twin {} account: {:?}",
                twin_id, b
            );
            (<T as Config>::Currency::total_balance(&t.account_id)
                - <T as Config>::Currency::minimum_balance())
            .min(*b)
        });

        // Unlock all balance for the twin
        <T as Config>::Currency::remove_lock(GRID_LOCK_ID, &t.account_id);
        writes += 1;

        if let Some(should_lock) = should_lock {
            debug!("we should lock: {:?}", should_lock);
            // Only do a set lock if we actually have to lock
            <T as Config>::Currency::set_lock(
                GRID_LOCK_ID,
                &t.account_id,
                should_lock,
                WithdrawReasons::all(),
            );
            writes += 1;
        }
    }

    // Update pallet storage version
    PalletVersion::<T>::set(types::StorageVersion::V8);
    debug!(" <<< Storage version upgraded");

    info!("ðŸ‘¥  Smart Contract pallet to V8 succeeded");
    // Return the weight consumed by the migration.
    T::DbWeight::get().reads(reads) + T::DbWeight::get().writes(writes + 1)
}

fn get_usable_balance<T: Config>(account_id: &T::AccountId) -> BalanceOf<T> {
    let balance = pallet_balances::pallet::Pallet::<T>::usable_balance(account_id);
    let b = balance.saturated_into::<u128>();
    BalanceOf::<T>::saturated_from(b)
}

pub fn get_locked_balance<T: Config>(account_id: &T::AccountId) -> BalanceOf<T> {
    let usable_balance = get_usable_balance::<T>(account_id);

    let free_balance = <T as Config>::Currency::free_balance(account_id);

    let locked_balance = free_balance.checked_sub(&usable_balance);
    locked_balance.unwrap_or_default()
}